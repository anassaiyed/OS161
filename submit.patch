diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..e946dd3 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -35,6 +35,10 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+#include <addrspace.h>
+#include <proc.h>
+#include <copyinout.h>
+#include <file.h>
 
 
 /*
@@ -81,6 +85,11 @@ syscall(struct trapframe *tf)
 	int callno;
 	int32_t retval;
 	int err;
+	off_t pos=0;
+	off_t retval64=0;
+	//off_t temp=0, temp1=0;
+	int retval_low=0;
+	int whence;
 
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
@@ -98,18 +107,64 @@ syscall(struct trapframe *tf)
 	 */
 
 	retval = 0;
-
+       // int64_t retval1;
 	switch (callno) {
 	    case SYS_reboot:
-		err = sys_reboot(tf->tf_a0);
+			err = sys_reboot(tf->tf_a0);
 		break;
 
 	    case SYS___time:
-		err = sys___time((userptr_t)tf->tf_a0,
-				 (userptr_t)tf->tf_a1);
+			err = sys___time((userptr_t)tf->tf_a0,
+					 (userptr_t)tf->tf_a1);
+		break;
+            case SYS_open:
+			err = sys_open((userptr_t) tf->tf_a0, tf->tf_a1, tf->tf_a2,&retval);
+		break;
+
+		case SYS_read:
+		err = sys_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2,&retval);
 		break;
 
-	    /* Add stuff here */
+	    case SYS_write:
+		err = sys_write(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2,&retval);
+		break;
+            
+              case SYS_close:
+			err=sys_close(tf->tf_a0, &retval);
+		break;
+ 
+             case SYS_fork:
+                         err = 0;
+                         err = sys_fork(tf,&retval);
+                         break;
+              case SYS_getpid:
+                         err = 0;
+                         err = justpid(&retval);
+                         break;                        
+              case SYS_waitpid: 
+                          err =0;
+                          err = waitpid((pid_t)tf->tf_a0,(int *)tf->tf_a1,tf->tf_a2,&retval);
+                         break;  
+              case SYS__exit:
+                         err =0;
+                         sys_exit(tf->tf_a0);
+                         break; 
+         case SYS_lseek:
+			pos = (off_t) ((off_t)tf->tf_a2 << 32 | (off_t)tf->tf_a3);
+			//kprintf("\na2_high: %d\na3_low: %d\npos: %llu\n",tf->tf_a2,tf->tf_a3,pos);
+			err = copyin((const_userptr_t)tf->tf_sp+16,&whence,sizeof(int));
+			if(!err)
+			{
+				err = sys_lseek(tf->tf_a0,pos,whence,&retval64);
+				if(!err) 
+				{
+					retval = retval64 >> 32;
+					retval_low = (int) retval64;
+				}
+			}
+		break;
+
+    /* Add stuff here */
  
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
@@ -130,6 +185,7 @@ syscall(struct trapframe *tf)
 	else {
 		/* Success. */
 		tf->tf_v0 = retval;
+		tf->tf_v1 = retval_low;
 		tf->tf_a3 = 0;      /* signal no error */
 	}
 	
@@ -155,7 +211,33 @@ syscall(struct trapframe *tf)
  * Thus, you can trash it and do things another way if you prefer.
  */
 void
-enter_forked_process(struct trapframe *tf)
+enter_forked_process(void *data1,unsigned long data2)
 {
-	(void)tf;
+ 
+  struct trapframe* child_tf;
+  struct addrspace *child_addr;
+
+   data1 = (struct trapframe *)data1;
+   child_tf = data1;
+
+   child_tf->tf_a3 = 0;
+   child_tf->tf_v0 = 0;
+
+   child_tf->tf_epc = child_tf->tf_epc + 4;
+
+
+
+
+  child_addr = (struct addrspace *)data2;
+
+  as_copy(child_addr,&curthread->t_addrspace);
+  as_activate(curthread->t_addrspace);
+
+  mips_usermode(child_tf);
+  
+   (void)data1;
+   (void)data2;
+  	
 }
+
+
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..13a8e96 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -367,6 +367,8 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/file.c
+file      syscall/proc.c
 
 #
 # Startup and initialization
diff --git a/kern/include/file.h b/kern/include/file.h
new file mode 100644
index 0000000..7895618
--- /dev/null
+++ b/kern/include/file.h
@@ -0,0 +1,31 @@
+#ifndef _FILE_H_
+#define _FILE_H_
+
+#include <lib.h>
+#include <device.h>
+#include <uio.h>
+#include <fs.h>
+#include <vnode.h>
+#include <thread.h>
+
+#define MAX_FILENAME_LEN 1024
+
+struct file_desc{
+    char name[MAX_FILENAME_LEN];
+    struct vnode* vn;
+    int flags;
+    off_t offset;
+    int ref_count;
+    struct lock* lock;
+};
+
+
+//int fd_table_init(struct thread *thr);
+int fd_table_init(struct thread *thr);
+int sys_open(userptr_t filename, int flags, int mode, int *retval);
+int sys_close(int fd, int *retval);
+int sys_read(int fd, userptr_t buf, size_t buflen, int *retval);
+int sys_write(int fd, userptr_t buf, size_t nbytes, int *retval);
+int sys_lseek(int fd, off_t pos, int whence, off_t *retval);
+
+#endif
diff --git a/kern/include/proc.h b/kern/include/proc.h
new file mode 100644
index 0000000..e8cf0e6
--- /dev/null
+++ b/kern/include/proc.h
@@ -0,0 +1,32 @@
+#ifndef _PROC_H_
+#define _PROC_H_
+
+struct proc_table{
+
+  pid_t pid;
+  pid_t ppid;
+  struct thread *proc_thread;
+  bool status;
+  int exit_code;
+  struct lock *proc_lock;
+  struct cv *proc_cv;
+ };
+
+
+// function listings
+
+// sys_fork
+// sys_execv
+// sys_waitpid
+
+pid_t makepid(struct thread *pid_thread);
+int justpid(int *retval);
+int sys_fork(struct trapframe *tf,int *retval);
+int waitpid(pid_t pid, int *status, int options,int *retval);
+void sys_exit(int exitcode);
+void mywait(struct proc_table *pro);
+
+
+
+#endif /* proc_h_ */
+
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..8b0cdf9 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -74,10 +74,16 @@ void V(struct semaphore *);
  */
 struct lock {
         char *lk_name;
+        struct wchan *lk_wchan;
+        struct spinlock lk_lock;
+        volatile int lk_held;
+        struct thread *lk_owner;
         // add what you need here
         // (don't forget to mark things volatile as needed)
 };
 
+#define MAXCNT 1000    //Maximum number of simultaneous readers.
+
 struct lock *lock_create(const char *name);
 void lock_acquire(struct lock *);
 
@@ -115,6 +121,7 @@ struct cv {
         char *cv_name;
         // add what you need here
         // (don't forget to mark things volatile as needed)
+        struct wchan *cv_wchan;
 };
 
 struct cv *cv_create(const char *name);
@@ -143,6 +150,8 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
 
 struct rwlock {
         char *rwlock_name;
+        struct semaphore *rw_sem;
+        struct lock *rw_lock;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..62bf37f 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -44,7 +44,7 @@ void syscall(struct trapframe *tf);
  */
 
 /* Helper for fork(). You write this. */
-void enter_forked_process(struct trapframe *tf);
+void enter_forked_process(void *data1,unsigned long data2);
 
 /* Enter user mode. Does not return. */
 void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..a888c17 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,8 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <limits.h>
+#include <file.h>
 
 struct addrspace;
 struct cpu;
@@ -112,6 +114,13 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+
+	/* File descriptor table */
+	struct file_desc* fd_table[OPEN_MAX];
+
+        pid_t pid;
+        pid_t ppid;
+        
 };
 
 /* Call once during system startup to allocate data structures. */
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..cf302eb 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -100,7 +100,7 @@ boot(void)
 	kprintf("%s", harvard_copyright);
 	kprintf("\n");
 
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n", 
+	kprintf("msaiyed@buffalo.edu avishekd@buffalo.edu's system version %s (%s #%d)\n", 
 		GROUP_VERSION, buildconfig, buildversion);
 	kprintf("\n");
 
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..a431f8d 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -40,6 +40,9 @@
 #include <sfs.h>
 #include <syscall.h>
 #include <test.h>
+#include <synch.h>
+#include <current.h>
+#include <proc.h>
 #include "opt-synchprobs.h"
 #include "opt-sfs.h"
 #include "opt-net.h"
@@ -53,6 +56,9 @@
 #define MAXMENUARGS  16
 
 // XXX this should not be in this file
+
+extern struct proc_table *proc[20];
+
 void
 getinterval(time_t s1, uint32_t ns1, time_t s2, uint32_t ns2,
 	    time_t *rs, uint32_t *rns)
@@ -127,7 +133,8 @@ int
 common_prog(int nargs, char **args)
 {
 	int result;
-
+       // pid_t pid;
+       // struct proc_table *singlep;
 #if OPT_SYNCHPROBS
 	kprintf("Warning: this probably won't work with a "
 		"synchronization-problems kernel.\n");
@@ -141,6 +148,20 @@ common_prog(int nargs, char **args)
 		kprintf("thread_fork failed: %s\n", strerror(result));
 		return result;
 	}
+        
+	proc[1] = (struct proc_table *)kmalloc(sizeof(struct proc_table));
+
+    curthread->pid = 1;
+    proc[1]->pid = 1;
+    proc[1]->exit_code = 0;
+    proc[1]->status = 0;
+    proc[1]->proc_lock = lock_create("Process_lock");
+    proc[1]->proc_cv = cv_create("Process_cv");
+    proc[1]->proc_thread = curthread;
+
+	lock_acquire(proc[1]->proc_lock);
+	mywait(proc[1]);
+	lock_release(proc[1]->proc_lock);
 
 	return 0;
 }
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..7e38240 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -47,15 +47,43 @@
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+static int male_cnt=0, female_cnt=0, matchmaker_cnt=0;
+static struct lock *lock;
+static struct cv *male_cv, *female_cv, *matchmaker_cv;
+
+//Variables for Buffalo Intersections
+static struct lock *lock_quad[4], *lock_getlock;
+
 void whalemating_init() {
-  return;
+
+  lock=lock_create("lock");
+  if(lock==NULL) {
+      panic("Can't create lock in whale mating.");
+  }
+
+  male_cv=cv_create("male_cv");
+  if(male_cv==NULL) {
+      panic("can't create male cv");
+  }
+  female_cv=cv_create("female_cv");
+  if(female_cv==NULL) {
+      panic("can't create female cv");
+  }
+  matchmaker_cv=cv_create("matchmaker_cv");
+  if(matchmaker_cv==NULL) {
+      panic("can't create matchmaker cv");
+  }
+
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
-  return;
+  lock_destroy(lock);
+  cv_destroy(male_cv);
+  cv_destroy(female_cv);
+  cv_destroy(matchmaker_cv);
 }
 
 void
@@ -65,7 +93,22 @@ male(void *p, unsigned long which)
   (void)which;
   
   male_start();
+
 	// Implement this function 
+  lock_acquire(lock);
+  male_cnt++;
+  if(female_cnt>0 && matchmaker_cnt>0)
+  {
+    cv_signal(female_cv,lock);
+    cv_signal(matchmaker_cv,lock);
+  }
+  else
+  {
+    cv_wait(male_cv,lock);
+  }
+  male_cnt--;
+  lock_release(lock);
+
   male_end();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -81,7 +124,22 @@ female(void *p, unsigned long which)
   (void)which;
   
   female_start();
+
 	// Implement this function 
+  lock_acquire(lock);
+  female_cnt++;
+  if(male_cnt>0 && matchmaker_cnt>0)
+  {
+    cv_signal(male_cv,lock);
+    cv_signal(matchmaker_cv,lock);
+  }
+  else
+  {
+    cv_wait(female_cv,lock);
+  }
+  female_cnt--;
+  lock_release(lock);
+
   female_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -97,7 +155,22 @@ matchmaker(void *p, unsigned long which)
   (void)which;
   
   matchmaker_start();
+
 	// Implement this function 
+  lock_acquire(lock);
+  matchmaker_cnt++;
+  if(male_cnt>0 && female_cnt>0)
+  {
+    cv_signal(male_cv,lock);
+    cv_signal(female_cv,lock);
+  }
+  else
+  {
+    cv_wait(matchmaker_cv,lock);
+  }
+  matchmaker_cnt--;
+  lock_release(lock);
+
   matchmaker_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -138,22 +211,57 @@ matchmaker(void *p, unsigned long which)
 // the top of the corresponding driver code.
 
 void stoplight_init() {
-  return;
+  lock_quad[0]=lock_create("lock1");
+  if(lock_quad[0]==NULL) {
+      panic("Can't create lock 1 in buffalo intersection.");
+  }
+  lock_quad[1]=lock_create("lock2");
+  if(lock_quad[1]==NULL) {
+      panic("Can't create lock 2 in buffalo intersection.");
+  }
+  lock_quad[2]=lock_create("lock3");
+  if(lock_quad[2]==NULL) {
+      panic("Can't create lock 3 in buffalo intersection.");
+  }
+  lock_quad[3]=lock_create("lock4");
+  if(lock_quad[3]==NULL) {
+      panic("Can't create lock 4 in buffalo intersection.");
+  }
+  lock_getlock=lock_create("lockGetLock");
+  if(lock_getlock==NULL) {
+      panic("Can't create lock getLock in buffalo intersection.");
+  }
+  //return;
 }
 
 // 20 Feb 2012 : GWA : Adding at the suggestion of Nikhil Londhe. We don't
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
-  return;
+  lock_destroy(lock_quad[0]);
+  lock_destroy(lock_quad[1]);
+  lock_destroy(lock_quad[2]);
+  lock_destroy(lock_quad[3]);
+  lock_destroy(lock_getlock);
+  //return;
 }
 
 void
 gostraight(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+  //(void)direction;
   
+  lock_acquire(lock_getlock);
+    lock_acquire(lock_quad[direction]);
+    lock_acquire(lock_quad[(direction+3)%4]);
+  lock_release(lock_getlock);
+  inQuadrant(direction);                    //in first quadrant (from 2 quadrants)
+  inQuadrant((direction+3)%4);              //in second quadrant (from 2 quadrants)
+  leaveIntersection();                      //leave intersection
+  lock_release(lock_quad[direction]);
+  lock_release(lock_quad[(direction+3)%4]);
+
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
   V(stoplightMenuSemaphore);
@@ -164,7 +272,20 @@ void
 turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+  //(void)direction;
+
+  lock_acquire(lock_getlock);
+    lock_acquire(lock_quad[direction]);
+    lock_acquire(lock_quad[(direction+3)%4]);
+    lock_acquire(lock_quad[(direction+2)%4]);
+  lock_release(lock_getlock);
+  inQuadrant(direction);                    //in first quadrant (from 3 quadrants)
+  inQuadrant((direction+3)%4);              //in second quadrant (from 3 quadrants)
+  inQuadrant((direction+2)%4);              //in third quadrant (from 3 quadrants)
+  leaveIntersection();                      //leave intersection
+  lock_release(lock_quad[direction]);
+  lock_release(lock_quad[(direction+3)%4]);
+  lock_release(lock_quad[(direction+2)%4]);
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -176,7 +297,14 @@ void
 turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+  //(void)direction;
+
+  lock_acquire(lock_getlock);
+    lock_acquire(lock_quad[direction]);
+  lock_release(lock_getlock);
+  inQuadrant(direction);
+  leaveIntersection();
+  lock_release(lock_quad[direction]);
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
diff --git a/kern/syscall/.proc.c.swo b/kern/syscall/.proc.c.swo
new file mode 100644
index 0000000..9b5de8f
Binary files /dev/null and b/kern/syscall/.proc.c.swo differ
diff --git a/kern/syscall/file.c b/kern/syscall/file.c
new file mode 100644
index 0000000..e011bba
--- /dev/null
+++ b/kern/syscall/file.c
@@ -0,0 +1,400 @@
+/*
+	File system calls
+*/
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <array.h>
+#include <spl.h>
+#include <thread.h>
+#include <current.h>
+#include <vfs.h>
+#include <synch.h>
+#include <mainbus.h>
+#include <vnode.h>
+#include <file.h>
+#include <copyinout.h>
+#include <kern/stat.h>
+#include <kern/seek.h>
+
+
+int fd_table_init(struct thread *thr)
+{
+	int result;
+	char fname[]="con:";
+	char fname1[]="con:";
+	char fname2[]="con:";
+	struct vnode *v0;
+	struct vnode *v1;
+	struct vnode *v2;
+
+	if(thr->fd_table[0] == NULL)
+	{
+		thr->fd_table[0] = (struct file_desc *)kmalloc(sizeof(struct file_desc));
+		result = vfs_open(fname, O_RDONLY, 0664, &v0);
+		if(result)
+		{
+			kprintf("file table initialization failed\n");
+			return EINVAL;
+		}
+		strcpy(thr->fd_table[0]->name,fname);
+		thr->fd_table[0]->vn = v0;
+		thr->fd_table[0]->flags = O_RDONLY;
+		thr->fd_table[0]->offset = 0;
+		thr->fd_table[0]->lock = lock_create(fname);
+		thr->fd_table[0]->ref_count=1;
+	}
+
+	if(thr->fd_table[1] == NULL)
+	{
+		thr->fd_table[1] = (struct file_desc *)kmalloc(sizeof(struct file_desc));
+		result = vfs_open(fname1, O_WRONLY, 0664, &v1);
+		if(result)
+		{
+			kprintf("file table initialization failed\n");
+			return EINVAL;
+		}
+		strcpy(thr->fd_table[1]->name,fname);
+		thr->fd_table[1]->vn = v1;
+		thr->fd_table[1]->flags = O_WRONLY;
+		thr->fd_table[1]->offset = 0;
+		thr->fd_table[1]->lock = lock_create(fname);
+		thr->fd_table[1]->ref_count=1;
+	}
+
+	if(thr->fd_table[2] == NULL)
+	{
+		thr->fd_table[2] = (struct file_desc *)kmalloc(sizeof(struct file_desc));
+		result = vfs_open(fname2, O_WRONLY, 0664, &v2);
+		if(result)
+		{
+			kprintf("file table initialization failed2\n");
+			return EINVAL;
+		}
+		strcpy(thr->fd_table[2]->name,fname);
+		thr->fd_table[2]->vn = v2;
+		thr->fd_table[2]->flags = O_WRONLY;
+		thr->fd_table[2]->offset = 0;
+		thr->fd_table[2]->lock = lock_create(fname);
+		thr->fd_table[2]->ref_count=1;
+	}
+
+	return 0;
+
+}
+
+int sys_open(userptr_t filename, int flags, int mode, int *retval)
+{
+	int result, i;
+	struct vnode *v;
+	size_t siz;
+	char *fname = (char *)kmalloc(sizeof(char)*PATH_MAX);
+
+	if(!(flags&O_RDONLY || flags&O_WRONLY || flags&O_RDWR))
+		return EINVAL;
+
+	if(filename==NULL)
+		return EFAULT;
+
+	result=copyinstr(filename, fname, PATH_MAX, &siz);
+	if(result)
+		return result;
+
+	//Check for modes remaining.
+
+	for(i=3;i<OPEN_MAX;i++)
+	{
+		if(curthread->fd_table[i]==NULL)
+			break;
+	}
+	if(i==OPEN_MAX)
+		return ENFILE;
+
+	curthread->fd_table[i] = (struct file_desc *)kmalloc(sizeof(struct file_desc));
+
+	if(curthread->fd_table[i] == NULL)
+	{
+		return ENFILE;
+	}
+
+	result = vfs_open(fname, flags, mode, &v);
+	//kprintf("vfs_open result: %d %d",result,flags);
+	if(result)
+		return result;
+
+	strcpy(curthread->fd_table[i]->name,fname);
+	curthread->fd_table[i]->vn = v;
+	curthread->fd_table[i]->flags = flags;
+	curthread->fd_table[i]->offset = 0;
+	curthread->fd_table[i]->lock = lock_create(fname);
+	curthread->fd_table[i]->ref_count=1;
+
+	kfree(fname);
+
+	*retval=i;
+
+	return 0;
+
+}
+
+int sys_close(int fd, int *retval)
+{
+	if(fd<3 || fd>OPEN_MAX)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+	if(curthread->fd_table[fd]==NULL)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+
+	lock_acquire(curthread->fd_table[fd]->lock);
+	vfs_close(curthread->fd_table[fd]->vn);
+	if(curthread->fd_table[fd]->ref_count==1)
+	{
+		lock_release(curthread->fd_table[fd]->lock);
+		lock_destroy(curthread->fd_table[fd]->lock);
+		kfree(curthread->fd_table[fd]);
+		curthread->fd_table[fd]=NULL;
+	}
+	else
+	{
+		KASSERT(curthread->fd_table[fd]->ref_count > 1);
+		curthread->fd_table[fd]->ref_count--;
+		lock_release(curthread->fd_table[fd]->lock);
+	}
+	*retval=0;
+	return 0;
+}
+
+int sys_read(int fd, userptr_t buf, size_t buflen, int *retval)
+{
+	int result,mode;
+	struct iovec iov;
+	struct uio u_io;
+	size_t lenread;
+
+	if(fd<1 || fd>OPEN_MAX)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+	if(curthread->fd_table[fd]==NULL)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+
+	lock_acquire(curthread->fd_table[fd]->lock);
+
+	//void *kbuff=kmalloc(sizeof(buflen));
+
+	mode=curthread->fd_table[fd]->flags & O_ACCMODE;
+	if(mode == O_WRONLY)
+	{
+		lock_release(curthread->fd_table[fd]->lock);
+		return EBADF;
+	}
+
+	//uio_kinit(struct iovec *iov, struct uio *u, void *kbuf, size_t len, off_t pos, enum uio_rw rw)
+	uio_kinit(&iov, &u_io, buf, buflen, curthread->fd_table[fd]->offset, UIO_READ);
+	result = VOP_READ(curthread->fd_table[fd]->vn, &u_io);
+	if (result) {
+		lock_release(curthread->fd_table[fd]->lock);
+		return result;
+	}
+
+	//copyout(kbuff,buf,buflen);
+	//char *c=(char*)kbuff;
+	//kprintf("%c",*c);
+
+	curthread->fd_table[fd]->offset = u_io.uio_offset;
+	lenread = buflen - u_io.uio_resid;
+
+	lock_release(curthread->fd_table[fd]->lock);
+
+	*retval=lenread;
+	return 0;
+}
+
+int sys_write(int fd, userptr_t buf, size_t nbytes, int *retval)
+{
+	int result;
+	struct iovec iov;
+	struct uio u_io;
+	//size_t siz;
+	size_t lenread;
+
+	if(fd<1 || fd>OPEN_MAX)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+	if(curthread->fd_table[fd]==NULL)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+
+	lock_acquire(curthread->fd_table[fd]->lock);
+
+	//Not opened in RW or write mode.
+	if(!(curthread->fd_table[fd]->flags & O_WRONLY || curthread->fd_table[fd]->flags & O_RDWR))
+	{
+		lock_release(curthread->fd_table[fd]->lock);
+		return EBADF;
+	}
+
+	/*char *kbuff = (char *)kmalloc(nbytes);
+	copyinstr((userptr_t)buf, kbuff, strlen(kbuff), &siz);*/
+	//char *c=kbuff;
+	//kprintf("%c",*c);
+
+	uio_kinit(&iov, &u_io, buf, nbytes, curthread->fd_table[fd]->offset, UIO_WRITE);
+	result = VOP_WRITE(curthread->fd_table[fd]->vn, &u_io);
+	if (result)
+	{
+		lock_release(curthread->fd_table[fd]->lock);
+		return result;
+	}
+
+	curthread->fd_table[fd]->offset = u_io.uio_offset;
+	lenread = nbytes - u_io.uio_resid;
+
+	lock_release(curthread->fd_table[fd]->lock);
+	//kprintf("\n\nhii\n\n");
+	//result=lenread;
+	*retval=lenread;
+	return 0;
+}
+
+int sys_lseek(int fd, off_t pos, int whence, off_t *retval)
+{
+	int result;
+	off_t end;
+	struct stat statptr;
+
+	//kprintf("target: %llu",pos);
+
+	if(fd<1 || fd>OPEN_MAX)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+	if(curthread->fd_table[fd]==NULL)
+	{
+		//*retval=EBADF;
+		return EBADF;
+	}
+
+	lock_acquire(curthread->fd_table[fd]->lock);
+
+    if(pos<0)
+    {
+    	lock_release(curthread->fd_table[fd]->lock);
+    	return EINVAL;
+    }
+
+    if(!(whence==SEEK_SET || whence==SEEK_CUR || whence==SEEK_END))
+    {
+    	lock_release(curthread->fd_table[fd]->lock);
+    	return EINVAL;
+    }
+
+	if(whence==SEEK_CUR)
+	{
+		pos = curthread->fd_table[fd]->offset + pos;
+	}
+	else if (whence==SEEK_END)
+	{
+		VOP_STAT(curthread->fd_table[fd]->vn, &statptr);
+    	end = statptr.st_size;
+		pos = pos + end;
+	}
+	result = VOP_TRYSEEK(curthread->fd_table[fd]->vn, pos);
+	if (result) {
+		lock_release(curthread->fd_table[fd]->lock);
+		return result;
+	}
+
+	curthread->fd_table[fd]->offset = pos;
+
+	lock_release(curthread->fd_table[fd]->lock);
+
+	//kprintf("final: %llu\n",pos);
+	*retval=pos;
+	return 0;
+}
+
+/*
+int sys__getcwd(char *buf,size_t buflen,int *retval)
+{
+//  int vfs_getcwd(struct uio *buf);
+   
+  // Hence need to initialize a uio structure
+
+  struct iovec iov;
+  struct uio ku;
+  size_t size;
+  
+  char *filename = (char *)kmalloc(buflen);
+
+  // need to call kinit and then store result of getcwd into an int variable
+  // need to call kinit
+  uio_kinit(&iov,&ku,&filename,buflen-1,0,UIO_READ); 
+  int result = vfs_getcwd(&ku);
+  if(result)
+  {
+  // kprintf("vfs_getcwd failed (%s) \n",stderror(result));
+   return result;
+  }
+  
+  // references taken from menu.c
+
+    // null terminate 
+   filename[buflen-1-ku.uio_resid] = 0;
+
+   //need to copy the kernel buffer to the user buffer else there are compile problems
+   copyoutstr(filename,(userptr_t)buf,buflen,&size);
+  *retval = buflen-1-ku.uio_resid;
+   result = buflen-1-ku.uio_resid;
+   kfree(filename);
+   return result;
+   
+}
+// check and change
+int sys_chdir(const char *pathname,int *retval)
+{
+     // need to use vfs_chdir
+     // before that need to setup 
+   int result;
+   size_t size;
+
+    // no other process should acces the file while it is having its path changed
+   int a = splhigh();
+    // need to make a copy of the pathname and copy it to a new kernel buffer 
+    // using copyinstr
+   char *path = (char *)kmalloc(sizeof(char)*PATH_MAX);
+   copyinstr((const_userptr_t)pathname,path,PATH_MAX,&size);
+    // the pathname now is in the kernel buffer
+      
+   result = vfs_chdir(path); 
+   if(result)
+    {
+      splx(a);
+      return result;
+    }
+     
+    // success condition for pathname : it has been changed
+
+  *retval = 0;
+  kfree(path);
+  splx(a);
+  return 0;
+}
+
+*/
diff --git a/kern/syscall/proc.c b/kern/syscall/proc.c
new file mode 100644
index 0000000..87cfc14
--- /dev/null
+++ b/kern/syscall/proc.c
@@ -0,0 +1,223 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <thread.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+#include <test.h>
+#include <kern/wait.h>
+#include <proc.h>
+#include <file.h>
+#include <synch.h>
+#include <spl.h>
+
+struct proc_table* proc[20];
+
+ 
+pid_t makepid(struct thread *pid_thread)
+{
+  pid_t i;
+  pid_t pid;
+
+  int max_pid = 20;
+  
+  KASSERT(proc[0]==NULL); 
+  
+  for(i=2;i<=20;i++)
+   {
+    if(proc[i]==NULL)
+      {
+        break;
+      }
+    
+   }
+   
+  if(i==max_pid)
+    {
+      kprintf("\n At the limit");
+      return ENPROC;
+   }
+   
+  pid = i;
+  proc[i] = (struct proc_table *)kmalloc(sizeof(struct proc_table));
+   
+  pid_thread->pid = pid;
+  
+ proc[i]->pid = pid;
+ proc[i]->ppid = pid_thread->ppid;
+ proc[i]->exit_code = 0;
+ proc[i]->status = false;
+ proc[i]->proc_lock = lock_create("Process_lock");
+ proc[i]->proc_cv = cv_create("Process_cv");
+ proc[i]->proc_thread = pid_thread;
+ 
+ return pid;
+ 
+}
+
+
+int justpid(int *retval)
+ {
+   *retval =  curthread->pid;
+   return 0;
+ }
+
+
+
+int sys_fork(struct trapframe *tf,int *retval)
+{
+  struct trapframe *temp_tf;
+  struct addrspace *temp_addr;
+  struct thread *child_process; 
+   
+  temp_tf = kmalloc(sizeof(struct trapframe *));
+ 
+  bzero(temp_tf,sizeof(struct trapframe *));
+  memcpy(temp_tf,tf,sizeof(struct trapframe *));
+   
+  temp_addr = kmalloc(sizeof(struct addrspace));
+  
+  int result;
+  result = as_copy(curthread->t_addrspace,&temp_addr);
+  if(result)
+   {
+     *retval = result;
+      return ENOMEM;
+   }
+
+   int a = splhigh();
+//   int thread_fork(const char *name,
+  //              void (*func)(void *, unsigned long),
+    //            void *data1, unsigned long data2,
+      //          struct thread **ret);
+
+    result = thread_fork("child_process",enter_forked_process,(struct trapframe *)temp_tf,(unsigned long)temp_addr,&child_process);
+
+    if(result)
+     {
+       splx(a);
+       return result;
+     }
+
+    int i = 3;
+
+    for(i=3;i<OPEN_MAX;i++)
+     {
+        if(curthread->fd_table[i]!=NULL)
+         {
+             child_process->fd_table[i] = curthread->fd_table[i];
+         }
+         else
+          break;
+    }  
+
+   
+    child_process->ppid = curthread->pid;
+
+    // function to get a pid for the child
+   child_process->pid =  makepid(child_process);
+
+    *retval = child_process->pid;
+
+    splx(a);
+    kfree(temp_tf);
+    kfree(temp_addr);
+    return 0;
+     
+}
+
+
+
+int waitpid(pid_t pid,int *status,int options,int *retval)
+{
+  
+  struct proc_table *singlep;
+ // check if waiting on self
+  if(pid == curthread->pid)
+   {
+    // *retval = -1; 
+     return ECHILD;
+   }
+  
+   singlep = proc[pid];
+   // check if it is null 
+   if(singlep  == NULL)
+    {
+    // *retval = -1;
+     return ESRCH;
+     }
+   
+   // need to check if given pid is that of the parent of the current thread
+   if(singlep->pid == curthread->ppid)
+     {
+       // *retval = -1;
+        return ECHILD;
+       
+     } 
+  // need to check if any siblings are waiting 
+    // also verify that the parent is waiting on the child
+   if(singlep->ppid != curthread->pid)
+    {
+      return ECHILD;
+     // *retval = -1;
+    }
+
+   if(options!=0)
+    {
+       return EINVAL;
+      // *retval = -1; 
+    }   
+
+   // need to wait for child to exit
+ // put it into a function
+ lock_acquire(singlep->proc_lock);
+ 
+  while(singlep->status==0)
+    {
+     cv_wait(singlep->proc_cv,singlep->proc_lock);
+    }
+  
+  *status = singlep->exit_code;
+
+  proc[pid] = NULL;
+
+  lock_release(singlep->proc_lock);
+  
+  thread_exit(); 
+  
+  *retval = pid;
+
+  return 0;
+}
+
+void sys_exit(int exitcode)
+{
+  pid_t cur_pid;
+ 
+  cur_pid = curthread->pid;
+  
+  lock_acquire(proc[cur_pid]->proc_lock);    
+  
+  
+  proc[cur_pid]->status = 1;
+  proc[cur_pid]->exit_code = _MKWAIT_EXIT(exitcode); 
+  cv_broadcast(proc[cur_pid]->proc_cv,proc[cur_pid]->proc_lock);
+ 
+  lock_release(proc[cur_pid]->proc_lock); 
+   
+}
+ 
+void
+mywait(struct proc_table *pro)
+{
+  while(pro->status == 0)
+     {
+          cv_wait(pro->proc_cv,pro->proc_lock);
+     }
+}
+
+
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..8cbf28a 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -44,13 +44,18 @@
 #include <vfs.h>
 #include <syscall.h>
 #include <test.h>
-
+#include <file.h>
+#include <proc.h>
+#include <synch.h>
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
  *
  * Calls vfs_open on progname and thus may destroy it.
  */
+
+extern struct proc_table *proc[20];
+
 int
 runprogram(char *progname)
 {
@@ -66,6 +71,8 @@ runprogram(char *progname)
 
 	/* We should be a new thread. */
 	KASSERT(curthread->t_addrspace == NULL);
+	//Add this if memory problems occur.
+	//curthread->fd_table=NULL;
 
 	/* Create a new address space. */
 	curthread->t_addrspace = as_create();
@@ -95,10 +102,16 @@ runprogram(char *progname)
 		return result;
 	}
 
+	result = fd_table_init(curthread);
+	if(result)
+		panic("File descriptor initialization failed!\n");
+	
 	/* Warp to user mode. */
 	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
 			  stackptr, entrypoint);
 	
+          
+
 	/* enter_new_process does not return. */
 	panic("enter_new_process returned\n");
 	return EINVAL;
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..c5bc2cf 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -100,7 +100,7 @@ P(struct semaphore *sem)
          */
         KASSERT(curthread->t_in_interrupt == false);
 
-	spinlock_acquire(&sem->sem_lock);
+        spinlock_acquire(&sem->sem_lock);
         while (sem->sem_count == 0) {
 		/*
 		 * Bridge to the wchan lock, so if someone else comes
@@ -164,6 +164,16 @@ lock_create(const char *name)
         }
         
         // add stuff here as needed
+        lock->lk_wchan = wchan_create(lock->lk_name);
+        if (lock->lk_wchan == NULL) {
+            kfree(lock->lk_name);
+            kfree(lock);
+            return NULL;
+        }
+
+        spinlock_init(&lock->lk_lock);
+        lock->lk_held = 0;
+        lock->lk_owner = NULL;
         
         return lock;
 }
@@ -174,7 +184,10 @@ lock_destroy(struct lock *lock)
         KASSERT(lock != NULL);
 
         // add stuff here as needed
-        
+
+        KASSERT(lock->lk_owner == NULL);
+        spinlock_cleanup(&lock->lk_lock);
+        wchan_destroy(lock->lk_wchan);
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -183,26 +196,51 @@ void
 lock_acquire(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+        KASSERT(lock != NULL);
+        KASSERT(curthread->t_in_interrupt == false);
+        spinlock_acquire(&lock->lk_lock);
+        while(lock->lk_held != 0)
+        {
+            wchan_lock(lock->lk_wchan);
+            spinlock_release(&lock->lk_lock);
+            wchan_sleep(lock->lk_wchan);
+            spinlock_acquire(&lock->lk_lock);
+        }
+        KASSERT(lock->lk_held == 0);
+        lock->lk_held = 1;
+        lock->lk_owner = curthread;
+        spinlock_release(&lock->lk_lock);
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
 lock_release(struct lock *lock)
 {
         // Write this
-
-        (void)lock;  // suppress warning until code gets written
+        KASSERT(lock != NULL);
+        spinlock_acquire(&lock->lk_lock);
+        lock->lk_held=0;
+        lock->lk_owner=NULL;
+        wchan_wakeone(lock->lk_wchan);
+        spinlock_release(&lock->lk_lock);
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
         // Write this
+        if(lock->lk_held==1)
+        {
+            if(curthread==lock->lk_owner)
+                return true;
+            else
+                return false;
+        }
+        return false;
+        //(void)lock;  // suppress warning until code gets written
 
-        (void)lock;  // suppress warning until code gets written
-
-        return true; // dummy until code gets written
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -225,6 +263,13 @@ cv_create(const char *name)
                 kfree(cv);
                 return NULL;
         }
+
+        cv->cv_wchan = wchan_create(cv->cv_name);
+        if (cv->cv_wchan == NULL) {
+            kfree(cv->cv_name);
+            kfree(cv);
+            return NULL;
+        }
         
         // add stuff here as needed
         
@@ -239,6 +284,7 @@ cv_destroy(struct cv *cv)
         // add stuff here as needed
         
         kfree(cv->cv_name);
+        wchan_destroy(cv->cv_wchan);
         kfree(cv);
 }
 
@@ -246,22 +292,128 @@ void
 cv_wait(struct cv *cv, struct lock *lock)
 {
         // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+        KASSERT(cv!=NULL);
+        KASSERT(lock!=NULL);
+        wchan_lock(cv->cv_wchan);
+        lock_release(lock);
+        wchan_sleep(cv->cv_wchan);
+        lock_acquire(lock);
+        //(void)cv;    // suppress warning until code gets written
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
         // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+        KASSERT(cv!=NULL);
+        KASSERT(lock!=NULL);
+        KASSERT(lock_do_i_hold(lock));
+        wchan_wakeone(cv->cv_wchan);
+    	//(void)cv;    // suppress warning until code gets written
+    	//(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
-	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+    	// Write this
+        KASSERT(cv!=NULL);
+        KASSERT(lock!=NULL);
+        KASSERT(lock_do_i_hold(lock));
+        wchan_wakeall(cv->cv_wchan);
+    	//(void)cv;    // suppress warning until code gets written
+    	//(void)lock;  // suppress warning until code gets written
+}
+
+struct rwlock * rwlock_create(const char *name)
+{
+    struct rwlock *rwlock;
+
+    rwlock = kmalloc(sizeof(struct rwlock));
+    if (rwlock == NULL) {
+            return NULL;
+    }
+
+    rwlock->rwlock_name = kstrdup(name);
+    if (rwlock->rwlock_name==NULL) {
+            kfree(rwlock);
+            return NULL;
+    }
+    
+    // add stuff here as needed
+    rwlock->rw_sem=sem_create(rwlock->rwlock_name, MAXCNT);
+    if(rwlock->rw_sem==NULL) {
+        kfree(rwlock->rwlock_name);
+        kfree(rwlock);
+        return NULL;
+    }
+
+    rwlock->rw_lock=lock_create(rwlock->rwlock_name);
+    if(rwlock->rw_lock==NULL) {
+        kfree(rwlock->rwlock_name);
+        kfree(rwlock->rw_sem);
+        kfree(rwlock);
+        return NULL;
+    }
+    
+    return rwlock;
+}
+void rwlock_destroy(struct rwlock *rwlock)
+{
+    KASSERT(rwlock!=NULL);
+    kfree(rwlock->rwlock_name);
+    sem_destroy(rwlock->rw_sem);
+    lock_destroy(rwlock->rw_lock);
+    kfree(rwlock);
+    //(void) rwlock;
+}
+
+void rwlock_acquire_read(struct rwlock *rwlock)
+{
+    KASSERT(rwlock!=NULL);
+    KASSERT(!lock_do_i_hold(rwlock->rw_lock));
+    lock_acquire(rwlock->rw_lock);
+    P(rwlock->rw_sem);
+    lock_release(rwlock->rw_lock);
+    //(void) rwlock;
+}
+void rwlock_release_read(struct rwlock *rwlock)
+{
+    KASSERT(rwlock!=NULL);
+    //KASSERT(!lock_do_i_hold(rwlock->rw_lock));
+    //lock_acquire(rwlock->rw_lock);
+    V(rwlock->rw_sem);
+    //lock_release(rwlock->rw_lock);
+    //(void) rwlock;
+}
+void rwlock_acquire_write(struct rwlock *rwlock)
+{
+    int i=0;
+    KASSERT(rwlock!=NULL);
+    KASSERT(!lock_do_i_hold(rwlock->rw_lock));
+    lock_acquire(rwlock->rw_lock);
+    while(rwlock->rw_sem->sem_count < MAXCNT)
+    {
+        //wait for all the readers or writers to finish.
+    }
+    for(i=0;i<MAXCNT;i++)
+    {
+        P(rwlock->rw_sem);
+    }
+    lock_release(rwlock->rw_lock);
+    //(void) rwlock;
+}
+void rwlock_release_write(struct rwlock *rwlock)
+{
+    int i=0;
+    KASSERT(rwlock!=NULL);
+    //KASSERT(!lock_do_i_hold(rwlock->rw_lock));
+    //lock_acquire(rwlock->rw_lock);
+    for(i=0;i<MAXCNT;i++)
+    {
+        V(rwlock->rw_sem);
+    }
+    //lock_release(rwlock->rw_lock);
+    //(void) rwlock;
 }
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..0605543 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -118,6 +118,7 @@ struct thread *
 thread_create(const char *name)
 {
 	struct thread *thread;
+	int i;
 
 	DEBUGASSERT(name != NULL);
 
@@ -153,6 +154,10 @@ thread_create(const char *name)
 	thread->t_cwd = NULL;
 
 	/* If you add to struct thread, be sure to initialize here */
+	for(i=0;i<OPEN_MAX;i++)
+	{
+		thread->fd_table[i]=NULL;
+	}
 
 	return thread;
 }
@@ -238,6 +243,8 @@ static
 void
 thread_destroy(struct thread *thread)
 {
+	int i;
+
 	KASSERT(thread != curthread);
 	KASSERT(thread->t_state != S_RUN);
 
@@ -262,6 +269,23 @@ thread_destroy(struct thread *thread)
 	/* sheer paranoia */
 	thread->t_wchan_name = "DESTROYED";
 
+	// free the file desc table
+	for(i=3;i<OPEN_MAX;i++)
+	{
+		if(thread->fd_table[i] != NULL)
+		{
+			if(thread->fd_table[i]->vn != NULL)
+			{
+				if(thread->fd_table[i]->ref_count<1)
+				{
+					kfree(thread->fd_table[i]->vn);
+					lock_destroy(thread->fd_table[i]->lock);
+				}
+			}
+			kfree(thread->fd_table[i]);
+		}
+	}
+
 	kfree(thread->t_name);
 	kfree(thread);
 }
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
index b807ff6..bb1d83d 100644
--- a/user/testbin/fileonlytest/fileonlytest.c
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -128,17 +128,23 @@ main(int argc, char **argv)
 	// ended up where we wrote it. Tests read() and lseek(SEEK_SET).
 	
 	printf("Verifying write.\n");
-
+	//printf("buffer_count:%d.\n",BUFFER_COUNT-1);
 	for (i = BUFFER_COUNT - 1; i >= 0; i--) {
     target = i * sizeof(writebuf);
+    	//printf("before lseek.\n");
 		pos = lseek(fh, target, SEEK_SET);
+		//printf("after lseek.\n");
     if (pos != target) {
       err(1, "(verify) lseek failed: %llu != %llu", pos, target);
     }
+    	//printf("before read.\n");
 		len = read(fh, readbuf, sizeof(readbuf));
+		//printf("after read.\n");
+		//printf("before sizeof.\n");
 		if (len != sizeof(readbuf)) {
 			err(1, "read failed");
 		}
+		//printf("after sizeof.\n");
 		for (j = BUFFER_SIZE - 1; j >= 0; j--) {
 			if (readbuf[j] != i * j) {
 				err(1, "read mismatch: pos=%llu, readbuf[j]=%d, i*j=%d, i=%d, j=%d", pos, readbuf[j], i * j, i, j);
